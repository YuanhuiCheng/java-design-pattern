# 代理模式

**参考：** [两个小时带你深入剖析代理模式](https://www.bilibili.com/video/BV1M54y1X78p)

### 什么是代理？

由另一个对象来代替原对象来处理某些逻辑。

### 代理模式的优点

- 解耦
    - 削减模块或组件之间的耦合度
- 高扩展
    - 由于模块的解耦，可以随时添加任意功能或者修改之前的功能而不影响到原模块的正常执行。
- 总结：在不修改原对象代码的基础上，对原对象的功能进行修改或增强。

### Java中的代理模式

#### tips

- 目标类：原对象，需要通过代理对象控制它的访问，扩展其功能。
- 代理类：代理模式产生的对象，是原对象的“替身”，在原有基础上修改逻辑。

#### 代理模式分类

- 静态代理

    - 手写代理类的代码，代理类编译后执行。
    - 缺点：一旦接口或者父类发生了变动，则代理类的代码就得随之修改。代理类多的话就会变得很麻烦。
- 动态代理

    - 在内存中生成代理对象。整个过程在内存中进行，我们不需要手写代理类，也不存在代理类编译的过程，而是直接在运行期，在jvm中“凭空”造出一个代理类让我们使用。
    - 基于JDK（接口）的动态代理
        - **要求被代理对象（目标类）必须实现接口**
    - 基于CGLIB（父类）的动态代理

```
Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h);

// ClassLoader loader: 指定目标对象的类加载器即可，用于加载目标类及其接口的字节码文件。
// Class<?>[] interfaces: 指定目标类的实现的所有接口的字节码对象的数组。
// InvocationHandler h: 是一个接口，其中的invoke方法会在代理类对象调用方法时执行。所以，在此方法中完成增强或者扩展代码逻辑的编写。

Object invoke(Object proxy, Method method, Object[] args);

// proxy: 就是代理类对象的一个引用，也就是Proxy.newProxyInstance的返回值，此引用基本不会用到，忽略即可。
// method: 对应的是触发invoke执行的方法的反射对象的Method对象。
// args: 代理对象调用方法时，传递的实际参数。
```